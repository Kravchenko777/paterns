## Применимость
- Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, 
  причём типов состояний много, и их код часто меняется.
  
- Когда код класса содержит множество больших, похожих друг на друга, условных операторов, 
  которые выбирают поведения в зависимости от текущих значений полей класса.
  
-  Когда вы сознательно используете табличную машину состояний, построенную на условных операторах,
   но вынуждены мириться с дублированием кода для похожих состояний и переходов
## Шаги реализации
1. Определитесь с классом, который будет играть роль контекста. 
   Это может быть как существующий класс, в котором уже есть зависимость от 
   состояния, так и новый класс, если код состояний размазан по нескольким классам.

2. Создайте общий интерфейс состояний. Он должен описывать методы, 
   общие для всех состояний, обнаруженных в контексте. Заметьте, что 
   не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.

3. Для каждого фактического состояния создайте класс, реализующий 
   интерфейс состояния. Переместите код, связанный с конкретными 
   состояниями в нужные классы. В конце концов, все методы интерфейса 
   состояния должны быть реализованы во всех классах состояний.

4. Создайте в контексте поле для хранения объектов-состояний, 
   а также публичный метод для изменения значения этого поля.

5. Старые методы контекста, в которых находился зависимый от состояния 
   код, замените на вызовы соответствующих методов объекта-состояния.

6. В зависимости от бизнес-логики, разместите код, который переключает 
   состояние контекста либо внутри контекста, либо внутри классов конкретных состояний.

